<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Course Learning Reflections</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="stylereflect.css">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }

        header {
            background-color: #f4419a;
            color: white;
            text-align: center;
            padding: 2rem;
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
        }

        p {
            font-size: 1.2rem;
        }

        section {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            padding: 20px;
        }

        .reflection {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s ease-in-out;
        }

        .reflection:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        h2 {
            color: #f4419a;
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        ul li {
            background-color: #fbe9f2;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 5px;
            color: #333;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        table th, table td {
            padding: 1rem;
            border: 1px solid #eaeaea;
            text-align: left;
        }

        table th {
            background-color: #f4419a;
            color: white;
        }

        a {
            color: #f4419a;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            section {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            p, ul li {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Course Learning Reflections</h1>
        <p>Reflections on Problem-Solving Techniques, Efficiency, Design Principles, and More</p>
    </header>

    <section>
        <div class="reflection">
            <h2>1. What Are the Kinds of Problems We See in Nature?</h2>
            <ul>
                <li><strong>Iteration:</strong> Natural cycles like day and night, and organisms adapting to environmental conditions.</li>
                <li><strong>Recursion:</strong> Branching of trees and the DNA molecule's structure and ancient tower of brahma problem and the game of pingala series and more.</li>
                <li><strong>Backtracking:</strong> Seen in natural selection and Darwin's theory, where non-functional traits are pruned and in n queens problem and generaing the subsets and the all the possible words from the phone's digit and knight tour problem.</li>
            </ul>
        </div>

        <div class="reflection">
            <h2>2. Space and Time Efficiency</h2>
            <p><strong>Space Efficiency:</strong> The additional space required by an algorithm.</p>
            <p><strong>Time Efficiency:</strong> The total running time of an algorithm.</p>
            <p>Efficient algorithms deliver quicker results, scale better, and are more resource-efficient.</p>
            <table>
                <tr>
                    <th>Class of Problem</th>
                    <th>Order of Growth</th>
                </tr>
                <tr>
                    <td>Runtime remains constant regardless of input size</td>
                    <td>Constant</td>
                </tr>
                <tr>
                    <td>Runtime grows logarithmically with input size</td>
                    <td>Logarithmic</td>
                </tr>
                <tr>
                    <td>Runtime grows proportionally with input size</td>
                    <td>Linear</td>
                </tr>
                <tr>
                    <td>Runtime grows faster than linear but slower than quadratic</td>
                    <td>Linear Logarithmic</td>
                </tr>
                <tr>
                    <td>Runtime grows quadratically (e.g., nested loops)</td>
                    <td>Quadratic</td>
                </tr>
                <tr>
                    <td>Runtime grows steeper than quadratic</td>
                    <td>Cubic</td>
                </tr>
                <tr>
                    <td>Runtime grows exponentially with input size</td>
                    <td>Exponential</td>
                </tr>
            </table>
        </div>

        <div class="reflection">
            <h2>3. Takeaways from Design Principles</h2>
            <ul>
               <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            background: #f4f4f4;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        li span {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <h1>Algorithmic Concepts</h1>
    <ul>
        <li><span>Decomposition:</span> Breaks a large problem into smaller sub-problems, making it easier to manage and solve we have seen it in the activity of zombie child detection carried out in lab 1.</li>
        <li><span>Pattern Recognition:</span> Identifies recurring patterns to generalize solutions and transfer knowledge across domains we have seen it in representation system activity in lab 1 and  forts of india from portfolio.</li>
        <li><span>Abstraction:</span> Simplifies a problem by focusing on key features and ignoring unnecessary details we have seen it in  shapes and sizes of activity in lab 1 and guernica and abstrack model in portfoloio assignment.</li>
        <li><span>Brave and Cautious Travel:</span> Refers to graph traversal methods: "Brave" is Depth-First Search (DFS), while "Cautious" is Breadth-First Search (BFS).</li>
        <li><span>Pruning:</span> Eliminates irrelevant parts of a problem or data set to improve efficiency, as used in search algorithms like N-Queens and subset generation problem.</li>
        <li><span>Lazy Propagation/Evaluation:</span> Delays updates in data structures like segment trees until necessary, optimizing performance.</li>
        <li><span>Sliding Window:</span> Maintains relevant information within a moving window over data to optimize sub-array problems.</li>
        <li><span>Level Order Traversal:</span> Systematically visits nodes level by level, commonly used in BFS of trees.</li>
        <li><span>Hierarchical Data:</span> Organizes data in a parent-child tree structure, aiding in efficient navigation and organization.</li>
        <li><span>Edge Relaxation:</span> Updates shortest path distances in graph algorithms by refining estimates through connected edges used in dijkstras algorithm.</li>
        <li><span>Balancing and Rotations:</span> Maintains efficiency in tree structures (e.g., AVL trees) by ensuring balance through rotations.</li>
        <li><span>Kleene Closure:</span> Addresses the transitive property in graph theory, often used in finding strongly connected components or shortest paths.</li>
        <li><span>Pre-Computing:</span> Calculates and stores frequently used values in advance to enhance algorithm performance this technique is used in sparse table.</li>
        <li><span>Parental Dominance:</span> Enforces a hierarchical relationship in data structures like heaps, where parents dominate child values.</li>
        <li><span>Prefix and Suffix:</span> Substrings at the start and end of strings, used in text processing, pattern matching, and data analysis.</li>
        <li><span>Partitioning:</span> Divides a problem into smaller sub-problems to reduce complexity, used in sorting and graph algorithms.</li>
        <li><span>Bit Manipulations:</span> Efficiently works with binary data, optimizing computations and memory usage.</li>
        <li><span>Memoization:</span> Stores results of previous function calls to avoid redundant computations, enhancing efficiency in recursive algorithms.</li>
        <li><span>Invariants:</span> Conditions that remain constant during computations, ensuring correctness and simplifying debugging.</li>
        <li><span>Shortest Path Trees:</span> Structures that show shortest paths from a source to all other points in a graph, aiding in routing and navigation .</li>
    </ul>
</body>
</html>

                </head>
<body>
    <h1>4.Hierarchical Data and Tree Structures</h1>
    <ul>
       
    <h1>Hierarchical Data and Tree Structures</h1>
    <p>To manage hierarchical data effectively, we started with basic tree structures and gradually introduced new techniques to make operations like searching, inserting, and deleting faster and more efficient.:</p>
    
    <h2>Tree</h2>
    <p>A tree represents hierarchical relationships, like family trees or file systems, where each element (node) can have multiple children. However, a simple tree doesn't help much when it comes to speeding up searches or organizing data efficiently.</p>
    
    <h2>Binary Tree</h2>
    <p>A binary tree has two children, helping to organize data. it’s not efficient for operations like searching or inserting new nodes.</p>
    
    <h2>Binary Search Tree (BST)</h2>
    <p>An improvement over binary tree is A binary search tree (BST) it is basically a binary tree with binary search propertyin which the left child of a node is smaller, and the right child is larger. This speeds up searches, but if the tree  becomes left skewed or right skewed its time  complexity  to search and insert becomes O(n), which is suboptimal.</p>
    
    <h2>2-3 Tree</h2>
    <p>in order to solve the issue of BSt ie skewness 2-3 tree comes into picture.The 2-3 tree addresses the issue of skewness of  trees by being a self-balancing structure. Nodes can have two or three children,  the tree remains balanced and operations like searching are efficient with a time complexity of O(log n).</p>
    
    <h2>AVL Tree</h2>
    <p>An AVL tree takes balancing further by using rotations to maintain the height difference between the left and right subtrees of each node. This gives  O(log n) time complexity for operations but takes large number rotations during insertion and deletetions.</p>
    
    <h2>Red-Black Tree</h2>
    <p>To reduce the number of rotations , the Red-Black tree comes into picture (red or black) for nodes.  it is  efficient for operations with fewer rotations.</p>
    
    <h2>Heap (Priority Queue)</h2>
    <p>For prioritizing elements ( in task scheduling or priority queues), heaps are used. A heap is a binary tree which follows parental dominance where each parent node is either greater (max-heap) or smaller (min-heap) than its children. It ensures quick access to the highest or lowest priority element, with insertion and removal operations being efficient.</p>
    
    <h2>Trie</h2>
    <p>To handle strings and prefix-based searches, a trie stores characters in nodes. This makes it extremely efficient for operations like autocomplete or dictionary lookups, as searching, inserting, or deleting strings depends only on their length, not the total number of strings stored.</p>
</body>
</html>
    </ul>
            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array Query Algorithms</title>
</head>
<body>
    <h1>The Need for Array Query Algorithms</h1>
    <p>Array query algorithms are essential for efficiently retrieving information from specific ranges within given data. They are  useful in scenarios where  where we frequently query about data sub-range such as finding the sum, minimum, or maximum within a range. Without these algorithms, recalculating values for each query would be difficult, especially for large data. These algorithms help reduce time complexity, helps  for applications involving dynamic or static datas.</p>
    
    <h2>Principles of Array Query Algorithms</h2>
    <ul>
        <li><strong>Precomputation:</strong> Many algorithms, like lookup tables and sparse tables, works on precomputing values for different ranges to execute queries fastly.</li>
        <li><strong>Efficiency:</strong> The goal pf array query is to reduce time complexity from linear (O(n)) to logarithmic (O(log n)) or even constant time (O(1)).</li>
        <li><strong>Space-Time Tradeoff:</strong> While lookup tables provide constant-time queries, they require very large  memory. Sparse tables and segment trees optimize this  both space and query time.</li>
        <li><strong>Dynamic and Static Data:</strong> Algorithms like segment trees and Fenwick trees handle dynamic datasets well, while sparse tables are suited for static datasets with no updates.</li>
    </ul>
    
    <h2>Applications of Array Query Algorithms</h2>
    <ul>
        <li><strong>E-commerce Filtering:</strong> Platforms like Amazon use range queries to filter products by price, improving user experience.</li>
        <li><strong>Navigation Apps:</strong> Google Maps uses range queries to find locations within a specific distance.</li>
        <li><strong>Financial Platforms:</strong> Traders use range queries to analyze stock performance over time, aiding investment decisions.</li>
        <li><strong>Sports Analytics:</strong> Coaches use range queries to access player statistics over specific periods for strategic planning.</li>
        <li><strong>Weather Apps:</strong> Users can query historical weather data to make informed travel or activity plans.</li>
    </ul>
    
    <h2>Common Algorithms and Structures</h2>
    <h3>1. Lookup Tables</h3>
    <ul>
        <li>Precomputes results for all possible ranges.</li>
        <li>gives  constant-time query access but uses large space.</li>
        <li>Inefficient for dynamic datasets due to the need for complete recomputation after updates.</li>
    </ul>
    
    <h3>2. Segment Trees</h3>
    <ul>
        <li>Divides the dataset into segments, storing aggregated values in a binary tree.</li>
        <li>Handles updates and queries efficiently in O(log n) time.</li>
        <li>Suitable for dynamic systems requiring frequent updates and queries.</li>
    </ul>
    
    <h3>3. Fenwick Trees</h3>
    <ul>
        <li>Optimized for cumulative queries, such as prefix sums.</li>
        <li>Used in financial and monitoring systems.</li>
    </ul>
    
    <h3>4. Sparse Tables</h3>
    <ul>
        <li>Space-efficient compared to lookup tables.</li>
        <li>Provides quick access for static datasets without updates.</li>
    </ul>
    
    <h2>Implications</h2>
    <ul>
        <li><strong>Computational Efficiency:</strong> Range query algorithms improve performance in real-time systems and large-scale applications.</li>
        <li><strong>Scalability:</strong> Efficient query handling supports larger datasets and complex applications.</li>
        <li><strong>Usability:</strong> Enhanced user experience in apps and platforms where range queries are common.</li>
    </ul>
    
    
</html>
</body>
</html>


            </ul>
        </div>

        <div class="reflection">
          
        </div>
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Traversals and Graph Traversals</title>
    <style>
        table {
            width: 60%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h2>Tree Traversal Techniques</h2>
    <table>
        <thead>
            <tr>
                <th>Pre-order</th>
                <th>In-order</th>
                <th>Post-order</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>root -> left -> right</td>
                <td>left -> root -> right<br><em>gives elements in sorted order</em></td>
                <td>left -> right -> root</td>
            </tr>
        </tbody>
    </table>

    <h2>Graph Traversal Techniques</h2>
    <table>
        <thead>
            <tr>
                <th>DFS</th>
                <th>BFS</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    Brave ones<br>
                    Stack is used<br>
                    Tree edges are back edges
                </td>
                <td>
                    Cautious ones<br>
                    Queue is used<br>
                    Tree edges are cross edges
                </td>
            </tr>
        </tbody>
    </table>

   
        <div class="reflection">
            <h2>6) Difference Between Trees and Graphs</h2>
            <table>
                <tr>
                    <th>TREES</th>
                    <th>GRAPHS</th>
                </tr>
                <tr>
                    <td>Collections of nodes and edges</td>
                    <td>Collections of vertices and edges</td>
                </tr>
                <tr>
                    <td>Has a unique root node</td>
                    <td>No unique node</td>
                </tr>
                <tr>
                    <td>Acyclic</td>
                    <td>Cyclic</td>
                </tr>
                <tr>
                    <td>Pre-order, In-order, Post-order Traversal</td>
                    <td>DFS, BFS Traversal</td>
                </tr>
            </table>
        </div>
    <h3>aplication of trees and graphs and theier traversals.</h3>
    <ul>
        <h4>aplication of trees</h4>
        <li>trees are used in file system.</li>
        <li>trees are used in artificial intelligence.</li>
        <li>trees are used to implement searching and sorting algorithm.</li>
         <li> variants of trees are used to implement dictionaries.</li>
         <h5>aplication of Graphs</h5>
         <li>graphs are used in google maps for buildiong transportation system</li>
        <li>graphs are used in facebook and linkdein</li>
         <li>in operating systems </li>
        <li>in mapping systems </li>
        <h6>aplication of DFS</h6>
         <li>used to detect cycles in a graph</li>
        <li>used in path finding</li>
        <li>used in biparitite graph</li>
         <li> use in solving maze with one solution</li>
        <h7>aplication of BFS</h7>
         <li>used in crawlers</li>
        <li>used in social networking</li>
        <li>GPS systems</li>
         <li>cycle detection </li>
        
    </ul>

        <div class="reflection">
            <h2>7) Sorting and Searching Algorithms</h2>
            <ul>
                <li><strong>Sorting:</strong> Bubble Sort, Selection Sort, Insertion Sort, Quicksort, Mergesort, Heap Sort.</li>
                <table border="1">
  <thead>
    <tr>
      <th>Sorting Name</th>
      <th>Design Technique</th>
      <th>Principles Used</th>
      <th>Elements</th>
      <th>Stable?</th>
      <th>In Place?</th>
      <th>Efficiency Analysis</th>
      <th>Popular Variants</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bubble Sort</td>
      <td>Brute Force</td>
      <td>Swap</td>
      <td></td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Θ(n²)</td>
      <td>Cocktail sort, Brick Sort</td>
    </tr>
    <tr>
      <td>Selection Sort</td>
      <td>Brute Force</td>
      <td>Find minimum and swap</td>
      <td></td>
      <td>No</td>
      <td>Yes</td>
      <td>Θ(n²)</td>
      <td></td>
    </tr>
    <tr>
      <td>Insertion Sort</td>
      <td>Incremental Approach</td>
      <td>Copy Method</td>
      <td></td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Ω(n), Θ(n²), O(n²)</td>
      <td>Binary Insertion Sort</td>
    </tr>
    <tr>
      <td>Merge Sort</td>
      <td>Divide and Conquer</td>
      <td>Merge Technique</td>
      <td></td>
      <td>Yes</td>
      <td>No</td>
      <td>O(n log n)</td>
      <td>Top-down, Bottom-up</td>
    </tr>
    <tr>
      <td>Quick Sort</td>
      <td>Divide and Conquer</td>
      <td>Pivot, Partition Technique</td>
      <td></td>
      <td>No</td>
      <td>Yes</td>
      <td>O(n²) (worst), O(n log n) (average)</td>
      <td>Randomized Quick Sort</td>
    </tr>
    <tr>
      <td>Heap Sort</td>
      <td>Transform and Conquer</td>
      <td>Heap Property</td>
      <td></td>
      <td>No</td>
      <td>Yes</td>
      <td>O(n log n)</td>
      <td>Tournament Sort</td>
    </tr>
  </tbody>
</table>
                <li><strong>Searching:</strong> Binary Search (Logarithmic time for sorted data).</li>
            </ul>
        </div>
    </section>
     <h2>connection of sorting algorithms in real world</h2>
    
    <ul>
        
        <li><strong>Bubble Sort:</strong>It is used by a programmers as a basic learning algorithm. </li>
        <li><strong>Selection Sort:</strong>When the swap operation is costly we use selection sort ex: sort array of structures </li>
        <li><strong>Insertion Sort:</strong> when the data set is almost sorted </li>
        <li><strong>Merge Sort:</strong>used to sort the linked list and When there is a large amountt of data </li>
        <li><strong>Quick Sort:</strong>used to sort any random data</li>
        <li><strong>Heap Sort:</strong> to find n th largest or Smallest and used in priority queues</li>
        
    </ul>
  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Searching and String Matching Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        header {
            background-color: #4CAF50;
            color: white;
            padding: 20px 10px;
            text-align: center;
        }
        main {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #4CAF50;
        }
        h3 {
            color: #333;
            margin-top: 20px;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: Consolas, "Courier New", monospace;
        }
        footer {
            text-align: center;
            padding: 10px;
            margin-top: 20px;
            background-color: #4CAF50;
            color: white;
        }
    </style>
</head>
<body>
    <header>
        <h1>Searching and String Matching Algorithms</h1>
    </header>
    <main>
       
        
        <h2>Key Algorithms</h2>

        <h3>Brute Force  String Matching:</h3>
        <ul>
            <li>Simple and iterative  approach.</li>
            <li>Compares characters of the pattern with the text one by one.</li>
            <li>Time complexity: <code>O(mn)</code>, where <code>m</code> is the length of the pattern and <code>n</code> is the length of the text.</li>
            <li>Used in recommendation engines.</li>
            <li>Design principle: Brute Force</li>
        </ul>

        <h3>Knuth-Morris-Pratt (KMP) Algorithm:</h3>
        <ul>
            <li>Preprocesses the pattern to create a "prefix function" that helps in efficient pattern matching.</li>
            <li>Avoids redundant comparisons.</li>
            <li>Time complexity: <code>O(m + n)</code>.</li>
            <li>Used in DNA subsequence Matching.</li>
            
        </ul>

        <h3>Rabin-Karp Algorithm:</h3>
        <ul>
            <li>Uses hashing to quickly compare substrings of the text with the pattern.</li>
            <li>Can be optimized with rolling hash functions to reduce computation time.</li>
            <li>Time complexity: <code>O(mn)</code> in the worst case.</li>
             <li>Used in intrusion detection in cyber security.</li>
        </ul>

        <h3>Boyer-Moore Algorithm:</h3>
        <ul>
            <li>Uses a "bad symbol shift table" and a "good suffix shift table" to quickly skip large portions of the text.</li>
            <li>Highly efficient for large texts and long patterns.</li>
            <li>Time complexity: <code>O(mn)</code> in the worst case, but often linear in practice.</li>
            <li>Used in Searching pattern in webpages.</li>
            <li>Design principle: Space and Time trade off</li>
        </ul>
         <h3>Linear Search:</h3>
        <ul>
            <li> linear search is a simple search algorithms  which iterates to each element one by one.comlexity:O(N)</li>
            <li>Design principle: Brute Force</li>
           <ul> 
              <h3>Binary Search:</h3>
        <ul> 
            <li>Binary search is a searching algorithm whioch divides the search space into two equal halves by comparing middle element  with key.which more faster than linear search.complexity:O(log N)</li>
            <li>Design Principle:Decrease and Conquer</li>
        </ul>
    </main>
    <footer>
       
    </footer>
</body>
</html>
               <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Importance of Graph Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        h1 {
            color: #4CAF50;
            text-align: center;
        }
        h2 {
            color: #2E8B57;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }
        h3 {
            color: #4682B4;
        }
        ul {
            list-style-type: disc;
            margin: 10px 20px;
            padding-left: 20px;
        }
        p {
            margin: 10px 0;
        }
        li {
            margin: 5px 0;
        }
        body {
            max-width: 800px;
            margin: auto;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
        }
        a {
            color: #4CAF50;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Importance of Graph Algorithms</h1>
    <h2>1. Spanning Trees</h2>
    <p><strong>Definition:</strong> A connected, acyclic subgraph that includes all vertices.determined by kruskal's and prim's algorithm</p>
    <h3>Importance:</h3>
    <ul>
        <li>Minimizes network costs (ex: Minimum Spanning Tree).</li>
        <li>Eliminates redundancy (ex:, cycles).</li>
        <li>Used in clustering, network design, and power grids.</li>
    </ul>
    <h3>Applications:</h3>
    <ul>
        <li>Communication networks</li>
        <li>Circuit design</li>
        <li>water pipelining</li>
    </ul>

    <h2>2. Shortest Paths</h2>
    <p><strong>Definition:</strong> The minimum distance or cost between two nodes in a graph. determined by disjkstra and bellmanford and floyd algorithms.</p>
    <h3>Importance:</h3>
    <ul>
        <li>Optimizes routes (ex:GPS, logistics).</li>
        <li>Reduces resource usage in data flow or transportation.</li>
        <li>Essential for AI, robotics, and dynamic systems.</li>
    </ul>
    <h3>Applications:</h3>
    <ul>
        <li>Navigation</li>
        <li>Supply chains</li>
        <li>Computer network routing</li>
    </ul>
     <h1>Different Design techniques.</h3>
    <ul>
        
        <li><strong>Brute force:<strong>is a straight forward approach to solve the problem.seen in bubble sort ,selection sort,linear search,bfss</li>
        <li><strong>Decrease and conquer:<strong> it is based on exploiting th realtion between a solution to a given instance of a problem and its solution to its smaller instance.ex:insertion sort,binary search</li>
        <li><strong>Divide and conquer:<strong>a problem is divide into several sub problems of the same type ex:merge sort,Quick sort</li>
        <li><strong>Transform and conquer:<strong>first it transform problem and then it conqueres the problem.ex:Heap sort,Avl tree</li>
        <li><strong>Space and time tade off:<strong>ex:boyer moore</li>
        <li><strong>Dynamic programming:<strong>floyd,warshal</li>
        <li><strong>greedy technique:<strong>ex:prim's,kruskal's.dijkstra</li>
        
       
        
    </ul>


    
</body>
</html>
               
</body>
</html>
